# 거품정렬 Bubble sort
&nbsp;&nbsp;&nbsp;&nbsp;서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 방법이다.
* 안정 정렬(stable sort): 정렬되지 않은 상태에서 같은 키 값을 가진 원소의 순서가 정렬 후에도 유지된다.
* 1회전: 첫번째 원소 vs 두번째 원소, 두번째 원소 vs 세번째 원소, ..., (n-1)번째 원소 vs n번째 원소를 비교하면서 조건에 맞지 않는다면 자리를 교환한다.
<br/>=> 가장 큰 원소가 제일 뒤에 위치하게 된다.(오름차순) 맨 끝에 있는 원소 정렬에서 제외
<br/>2회전: 첫번째 원소 vs 두번째 원소, 두번째 원소 vs 세번째 원소, ..., (n-2)번째 원소 vs (n-1)번째 원소 비교하며 정렬
<br/>=> 끝에서 두번째 원소까지 정렬에서 제외
<br/>이 과정을 반복한다.<br/>

![image](https://user-images.githubusercontent.com/62373386/103970334-55763600-51ab-11eb-812b-4a9399cabe28.png)

![image](https://t1.daumcdn.net/cfile/tistory/99376B505C36A49A08)

```
int main()
{
    int N = 5;//배열 길이
    int i, j, temp;
    int data[] = { 5, 3, 7, 9, 1 };

    for (i = 0; i < N; i++) {
        for (j = 0; j < N-(i+1); j++) {
            if (data[j] > data[j+1]) {
                // 자리교환
                temp = data[j+1];
                data[j+1] = data[j];
                data[j] = temp;
            }
        }
    }
}
```

시간복잡도|공간복잡도
---|---
`O(n^2)`|`O(n)`

* 시간복잡도: `O(n^2)`<br/>
(n-1) + (n-2) + (n-3) + .... + 2 + 1 = n(n-1)/2
<br/> 한 번의 순회가 끝나면 비교할 원소가 하나씩 줄어든다. 전체 개수가 n개일 때 n-1번 순회하면 정렬이 끝난다. 정렬 여부와 관계 없이 2개의 원소를 비교하기 때문에 최선, 평균, 최악의 경우 시간복잡도가 동일하다. 단, 최선의 경우 자리 교환이 0번 이루어지고 최악의 경우 자리 교환이 n(n-1)/2번 이루어진다.
* 공간복잡도: `O(n)`<br/>
주어진 배열 안에서 교환(swap)

